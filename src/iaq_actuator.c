/***********************************************************************************************************************
* DISCLAIMER
* This software is supplied by Renesas Electronics Corporation and is only intended for use with Renesas products.
* No other uses are authorized. This software is owned by Renesas Electronics Corporation and is protected under all
* applicable laws, including copyright laws. 
* THIS SOFTWARE IS PROVIDED "AS IS" AND RENESAS MAKES NO WARRANTIES REGARDING THIS SOFTWARE, WHETHER EXPRESS, IMPLIED
* OR STATUTORY, INCLUDING BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NON-INFRINGEMENT.  ALL SUCH WARRANTIES ARE EXPRESSLY DISCLAIMED.TO THE MAXIMUM EXTENT PERMITTED NOT PROHIBITED BY
* LAW, NEITHER RENESAS ELECTRONICS CORPORATION NOR ANY OF ITS AFFILIATED COMPANIES SHALL BE LIABLE FOR ANY DIRECT,
* INDIRECT, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES FOR ANY REASON RELATED TO THIS SOFTWARE, EVEN IF RENESAS OR
* ITS AFFILIATES HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
* Renesas reserves the right, without notice, to make changes to this software and to discontinue the availability 
* of this software. By using this software, you agree to the additional terms and conditions found by accessing the 
* following link:
* http://www.renesas.com/disclaimer
*
* Copyright (C) 2020 Renesas Electronics Corporation. All rights reserved.
***********************************************************************************************************************/

/***********************************************************************************************************************
*  File Name    : iaq_actuator.c
*  Description  : Main Program
*  Creation Date: 2023-02-16
*  This file was generated by Smart Configurator.
***********************************************************************************************************************/
#include "app/app.h"
#include "app/elcl/elcl.h"

/** @brief Tones to be used by the DTC*/
uint8_t tones[MAXIMUM_SYSTEM_STATES][9] = {
		{0x8FU, 0x8FU, 0x8EU, 0x8EU, 0x8DU, 0x8DU, 0x8CU, 0x8CU, 0x00U},
		{0x8CU, 0x8CU, 0x8DU, 0x8DU, 0x8EU, 0x8EU, 0x8FU, 0x8FU, 0x00U},
		{0x8CU, 0x8DU, 0x8EU, 0x8FU, 0x8CU, 0x8DU, 0x8EU, 0x8FU, 0x00U},
};

/** @brief dtc data for tone generation*/
extern st_dtc_data_t __near dtc_controldata_0;

/** @brief Function to handle output states*/
static void App_handle_outputs(void)
{
	if(App_button_click_event())
	{
		CCS0 = (system_output_state % MAXIMUM_SYSTEM_STATES) + 1;
		CCDE |= 0x03U; /* Turn on LED's*/

		if((system_output_state > 0) && (system_output_state <= MAXIMUM_SYSTEM_STATES))
		{
			dtc_controldata_0.dtcct = _09_DTCD0_TRANSFER_BYTE;
			dtc_controldata_0.dtsar = (uint16_t)((__near uint8_t *)&tones[system_output_state-1]);
			R_DTCD0_Start();

			Start_timer_wfi();
		}
	}

	if(App_rotary_event())
	{
		/* Get rotary count and wrap around according to system states*/
		int16_t l_rot_count = Hw_get_rotary_count();

		prev_system_output_state = system_output_state;

		if((system_output_state + l_rot_count) <= 0)
		{
			system_output_state = MAXIMUM_SYSTEM_STATES + 1;
		}
		else if((system_output_state + l_rot_count) > MAXIMUM_SYSTEM_STATES)
		{
			system_output_state = 0;
		}
		else
		{
			/* Do Nothing*/
		}

		system_output_state += l_rot_count;

		App_update_display();
	}
}
/* END OF FUNCTION*/


void main(void)
{
	/* Enable handling of interrupts*/
	EI();

	/* Prepare drivers and display*/
	App_init();

	/* Initialise the ELCL*/
	Elcl_set_input(&elcl_ctl, ELCL_INPUT_4, ELCL_SRC_PIN1_611_INTC5);
	Elcl_set_input(&elcl_ctl, ELCL_INPUT_6, ELCL_SRC_P51);
	Elcl_link_input(&elcl_ctl, ELCL_BLOCK1, ELCL_LNK_2, ELCL_INPUT_REG_4, ELCL_INVERTED_LOGIC);
	Elcl_link_input(&elcl_ctl, ELCL_BLOCK1, ELCL_LNK_6, ELCL_INPUT_REG_6, ELCL_INVERTED_LOGIC);
	Elcl_link_input(&elcl_ctl, ELCL_BLOCK1, ELCL_LNK_0, ELCL_INPUT_REG_4, ELCL_INVERTED_LOGIC);
	Elcl_link_input(&elcl_ctl, ELCL_BLOCK1, ELCL_LNK_1, ELCL_INPUT_REG_6, ELCL_INVERTED_LOGIC);
	Elcl_set_logic(&elcl_ctl, ELCL_BLOCK1, ELCL_ENABLE_FLIPFLOP0);
	Elcl_set_logic(&elcl_ctl, ELCL_BLOCK1, ELCL_EXOR_CELL_0);
	Elcl_link_to_logic(&elcl_ctl, ELCL_BLOCK1, ELCL_LNK_2, ELCL_FLIP_FLOP0_INPUT);
	Elcl_link_to_logic(&elcl_ctl, ELCL_BLOCK1, ELCL_LNK_6, ELCL_FLIP_FLOP0_CLK);
	Elcl_link_to_logic(&elcl_ctl, ELCL_BLOCK1, ELCL_LNK_0, ELCL_CELL0_INPUT_0);
	Elcl_link_to_logic(&elcl_ctl, ELCL_BLOCK1, ELCL_LNK_1, ELCL_CELL0_INPUT_1);

	Elcl_link_input(&elcl_ctl, ELCL_BLOCK2, ELCL_LNK_0, ELCL_OUTPUT_FLIP_FLOP0_L1, ELCL_INVERTED_LOGIC);
	Elcl_link_input(&elcl_ctl, ELCL_BLOCK2, ELCL_LNK_1, ELCL_OUTPUT_FLIP_FLOP0_L1, ELCL_POSITIVE_LOGIC);
	Elcl_link_input(&elcl_ctl, ELCL_BLOCK2, ELCL_LNK_2, ELCL_OUTPUT_CELL0_L1, ELCL_INVERTED_LOGIC);
	Elcl_link_input(&elcl_ctl, ELCL_BLOCK2, ELCL_LNK_3, ELCL_OUTPUT_CELL0_L1, ELCL_INVERTED_LOGIC);
	Elcl_set_logic(&elcl_ctl, ELCL_BLOCK2, ELCL_AND_CELL_0);
	Elcl_set_logic(&elcl_ctl, ELCL_BLOCK2, ELCL_AND_CELL_1);
	Elcl_link_to_logic(&elcl_ctl, ELCL_BLOCK2, ELCL_LNK_0, ELCL_CELL0_INPUT_0);
	Elcl_link_to_logic(&elcl_ctl, ELCL_BLOCK2, ELCL_LNK_2, ELCL_CELL0_INPUT_1);
	Elcl_link_to_logic(&elcl_ctl, ELCL_BLOCK2, ELCL_LNK_1, ELCL_CELL1_INPUT_0);
	Elcl_link_to_logic(&elcl_ctl, ELCL_BLOCK2, ELCL_LNK_3, ELCL_CELL1_INPUT_1);

	Elcl_set_output(&elcl_ctl, ELCL_OUTPUT_3, ELCL_OUTPUT_L2_CELL0, ELCL_POSITIVE_LOGIC);
	Elcl_set_output(&elcl_ctl, ELCL_OUTPUT_4, ELCL_OUTPUT_L2_CELL1, ELCL_POSITIVE_LOGIC);
	Elcl_set_output_state(&elcl_ctl, ELCL_OUTPUT_3, ELCL_OUTPUT_ENABLED);
	Elcl_set_output_state(&elcl_ctl, ELCL_OUTPUT_4, ELCL_OUTPUT_ENABLED);

	while(1)
	{
		App_handle_outputs();
	}
}
/* END OF MAIN*/
