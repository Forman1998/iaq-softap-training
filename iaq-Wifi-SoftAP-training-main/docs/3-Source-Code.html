<!doctype html>
<html>

<head>
	<meta charset="utf-8">
	<!-- Useful for tablet and mobile based browsing-->
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<!-- Title of the page (not necessarily the lab) - for reference only, not displayed on the page-->
	<title>Source Code</title>
	<!-- CSS template stylesheet must be linked here-->
	<link href="css/renesas_layout_style.css" rel="stylesheet" type="text/css">
	<!-- Javascript based lab templating helper must be placed here-->
	<script type="text/javascript" src="js/lab-templater.js"></script>

	<!-- Addition of code highlighting Stylesheet & Script-->
	<link rel="stylesheet" href="js/highlight/styles/atom-one-light.min.css">
	<script type="text/javascript" src="js/highlight/highlight.min.js"></script>
	<script>hljs.highlightAll();</script>
</head>

<body>
	<!-- Populate the page header (banner, title & navigation menu)-->
	<script>lab_templater.Generate_header();</script>

	<!-- Begin the main content of the page-->
	<div class="main-content">

		<!-- Page/Section Summary & Description-->
		<summary>3. Source Code</summary>
		<p>Here we will guide you through both inclusion and understanding of the code for this project. The aim is to
			give an understanding of how to use smart configurator generated code, the e² studio build settings &amp;
			finally what the lab code does.
		</p>

		<!-- Start adding "details" sections for lab steps-->
		<details open>
			<summary>3.1 Pull In The Free Code</summary>
			<p>First we have to pull in the free code provided for this lab that is the hs4001 sensor library &amp; WiFi connection
				. We call this free code as it serves a fixed purpose and is only here to facilitate the
				training.<br><br>

				To acquire the free code please click <a href="dl/src.zip" download>here</a> to download &amp; extract
				the contents of the .zip archive.<br><br>

				Please copy the folder "app" into the "src" folder in your e² studio project.
			</p>
			<img class="modal-thumbnails" src="img/img_lab/copyfreecode.gif" alt="">
		</details>

		<details>
			<summary>3.2 Edit the IICA0 Driver</summary>
			<p>
				The I<sup>2</sup>C base driver doesn't provide the appropriate functionality out of the box - so let's edit it and
				give ourselves the functions we need, this is namely an I<sup>2</sup>C send function which triggers when there's a error or event completion flag.<br><br>
				Navigate to <b>[src] &rarr; [smc_gen] &rarr; [Config_IICA0] &rarr; Config_IICA0_user.c</b><br>
				You can edit the file in section starting with the "Start user code for function..." comment gaurd - place the following
				function declarations.
			</p>
			<p>
				<b>Function:</b> r_Config_IICA0_callback_master_sendend
				<pre>
					<code class="C">rm_comms_i2c_bus0_callback(false);</code>
				</pre>
			</p>
			<p>
				<b>Function:</b> r_Config_IICA0_callback_master_receiveend
				<pre>
					<code class="C">rm_comms_i2c_bus0_callback(false);</code>
				</pre>
			</p>
			<p>
				<b>Function:</b> r_Config_IICA0_callback_master_error
				<pre>
					<code class="C">rm_comms_i2c_bus0_callback(true);</code>
				</pre>
			</p>
			<p>Which should look like this:</p>
			<img class="modal-thumbnails" src="img/img_lab/i2csrc.png" alt="">
		</details>

		<details>
			<summary>3.3 Populate TAU00 ISR</summary>
			<p>
				The clockwise timer counter needs it's ISR populating - this ISR fires everytime timer runs out to make sure the UART connection with DA16200 functions timely. We fill this ISR with some code so the
				application can be made aware of a clockwise rotation.<br><br>
				Now first we need to include our "main.h" file from earlier to enable the ISR to communicate with the
				application.
				Navigate to the <b>[src] &rarr; [smc_gen] &rarr; [Config_TAU0_0] &rarr; Config_TAU0_0_user.c</b> &amp;
				copy the code below into the includes section of the file, inside the "Start user code for include..."
				comment gaurd.
			</p>
			<pre><code class="C">#include "HAL.h"</code></pre>
			<p>Then add the following the global variable declaration section</p>
			<pre>
				<code class="C">extern bool oneshot_timer_done;</code>
			</pre>
			<p>
				Finally inside the r_Config_TAU0_0_interrupt isr, please place the following code. This code
				signals to the application that the timer ran out. It also
				clears the interrupt flags <b>both</b> timers as a debounce precaution. It should be
				placed within the "Start user code for r_Config_TAU0_0_interrupt..." comment gaurd.
			</p>
			<pre>
			<code class="C">oneshot_timer_done = true;
R_Config_TAU0_0_Stop();</code>
			</pre>
			<p>The changes should look like this when finished:</p>
			<img class="modal-thumbnails" src="img/img_lab/tau00src.png" alt="">
		</details>

		<details>
			<summary>3.4 Populate TAU05 ISR</summary>
			<p>The sensor counter needs it's ISR populating - this ISR fires every milisecond to make sure the the steps of reading sensor value is initated. We fill this ISR with some code so the
				application functions properly.<br><br>
				Now first we need to include our function in the header file.
				Navigate to the <b>[src] &rarr; [smc_gen] &rarr; [Config_TAU0_5] &rarr; Config_TAU0_5.h</b> &amp;
				copy the code below at the end of the file, inside the "Start user code for function..."
				comment gaurd.
			</p>
			<pre><code class="C">void R_Config_TAU0_5_Blocking_Wait(void);</code></pre>
			<p>
				Next navigate to the corresponding <b>Config_TAU0_4_user.c</b> file ([src] &rarr; [smc_gen] &rarr;
				[Config_TAU0_5] &rarr; Config_TAU0_5_user.c) and please add the following code at the bottom of the file,
				again within the comment gaurd "Start user code for adding...".
			</p>
			<pre><code class="C">void R_Config_TAU0_5_Blocking_Wait(void)
{
	TMIF05 = 0U;    /* clear INTTM05 interrupt flag */
	TMMK05 = 1U;    /* disable INTTM05 interrupt */
	TS0 |= _0020_TAU_CH5_START_TRG_ON;

	while(0U == TMIF05)
	{
		NOP(); /* TODO: HALT*/
	}
	Sensor_read();
	TT0 |= _0020_TAU_CH5_STOP_TRG_ON;
	TMIF05 = 0U;    /* clear INTTM05 interrupt flag */
}</code></pre>
			<p>The changes should look like this when finished:</p>
			<img class="modal-thumbnails" src="img/img_lab/tau05src.png" alt="">
		</details>
		<details>
			<summary>3.5 Pull In The Main Code</summary>
			<p>Now lets copy in the main code - this is running the application.<br>
				Simply <b>replace</b> the entire contents of your main source file src/<i>&lt;project_name&gt;.c</i>
				with the code below.</p>

			<pre><code class="C">#include "r_smc_entry.h"
#include "da16200_AT.h"
#include "http_server.h"
#include "sensor.h"
#include &ltstring.h&gt

static uint8_t http_ip_port[500];
void main(void)
{
	http_receive_status http_status;
	EI();
	wifi_init();
	wifi_set();
	Sensor_read();
	while(1)
	{
		Sensor_read();
		memset(http_ip_port, 0, 500);
		http_status = HTTP_ERROR;
		/* Wi-Fi server data receive */
		http_status = http_server_receive(http_ip_port);
		switch(http_status)
		{
			/* HTTP GET command received */
			case HTTP_GET:
			http_update(http_ip_port);
			break;

			/* LED BLINK command received */
			case HTTP_LED_BLINK:
			CCS0 ^= 0x01U;
			break;

			/* HTTP OTHER command received */
			case HTTP_OTHERS:
			http_update(http_ip_port);
			break;

			default:
			break;
		}
	}
}</code></pre>
		</details>

		<details>
			<summary>3.10 Application Explained <i>[Informative]</i></summary>
			<p>As the section name implies this in informative, there are no actions in this step and it can be freely
				skipped. But this section aims to explain the application code and provide a clear understanding of why
				&amp; how certain things have been done. We will do this by combing through the code, picking out
				lines of code or groups of lines of code in order to dissect what is happening.<br><br>

				The application is inherently simple once configured - the main loop infinitely waits for either a
				button click or rotation event to be signalled from the hardware layer (ISR's).<br>
				These events are signalled through a variable hw_event_flags. The mechanism for setting and getting the
				events is provided through simple bit manipulation.<br>
				Each bit is defined in an enumerated typedef to clearly define the events which can be stored in the
				hardware event flags type hw_event_flags_t.<br>
				Setting and checking events has been simplified with macros in the application header defined.<br>
				The checking of this variable is done via copy during disabled interrupts to emulate a simplified
				critical section.<br>
				The image below shows the flowchart for the top level main loop.
			</p>
			<img class="modal-thumbnails" src="img/img_lab/actuator_lab_fc_main.png" alt=""><br>

			<p>For each of the two events (button click and rotation) there is a handling process.<br>
				A button click invokes the tone generation and latches the LED CCIO current strength corresponding to
				the system state.<br>
				The flowchart for executing this can be seen in the image below.
			</p>
			<img class="modal-thumbnails" src="img/img_lab/actuator_lab_fc_buttonclick.png" alt=""><br>

			<p>The rotation event simply invokes a system state change (output LED current strength &amp; tone sequence
				change) which is represented by simply writing a state number to the display. The new tone and LED CCIO
				current strength can be output by clicking the button.<br>
				The flowchart for executing this can be seen in the image below.
			</p>
			<img class="modal-thumbnails" src="img/img_lab/actuator_lab_fc_rotation.png" alt=""><br>

			<p>An important part of the intialisation process is the ELCL settings. We are aiming to achieve the
				following circuit:
			</p>
			<img class="modal-thumbnails" src="img/img_lab/rotarydecoding1.png" alt=""><br>

			<p>To do so there are 4 components when intialising the ELCL:</p>
			<ol>
				<li><b>Elcl_set_input</b>: Select the input pins - this means the ELCL inputs 4 & 6 are linked to their
					respecitve pins.
					<pre class="no-copy"><code class="C">Elcl_set_input(&elcl_ctl, ELCL_INPUT_4, ELCL_SRC_PIN1_611_INTC5);
Elcl_set_input(&elcl_ctl, ELCL_INPUT_6, ELCL_SRC_P51);</code></pre>
				</li>
				<li>ELCL Block 1:
					<ul>
						<li><b>Elcl_link_input</b>: Link input pins to to block 1's link registers - this means our
							input
							pins on inputs 4 & 6 are now linked to block 1's link registers 2,0 & 6,1 respecitvely.
							<pre class="no-copy"><code class="C">Elcl_link_input(&elcl_ctl, ELCL_BLOCK1, ELCL_LNK_2, ELCL_INPUT_REG_4, ELCL_INVERTED_LOGIC);
Elcl_link_input(&elcl_ctl, ELCL_BLOCK1, ELCL_LNK_6, ELCL_INPUT_REG_6, ELCL_INVERTED_LOGIC);
Elcl_link_input(&elcl_ctl, ELCL_BLOCK1, ELCL_LNK_0, ELCL_INPUT_REG_4, ELCL_INVERTED_LOGIC);
Elcl_link_input(&elcl_ctl, ELCL_BLOCK1, ELCL_LNK_1, ELCL_INPUT_REG_6, ELCL_INVERTED_LOGIC);</code></pre>
						</li>
						<li><b>Elcl_set_logic</b>: Enable the logic gates of interest in logic block 1 - this means we
							can
							enable the flip lop and EXOR gate or direction detection and clock generation respectively.
							<pre class="no-copy"><code class="C">Elcl_set_logic(&elcl_ctl, ELCL_BLOCK1, ELCL_ENABLE_FLIPFLOP0);
Elcl_set_logic(&elcl_ctl, ELCL_BLOCK1, ELCL_EXOR_CELL_0);</code></pre>
						</li>
						<li><b>Elcl_link_to_logic</b>: Link the input link registers for block 1 to the logic cells
							meaning
							link registers 2,6 & 0,1 are now connected to the flip flop and exor gates respectively.
							<pre class="no-copy"><code class="C">Elcl_link_to_logic(&elcl_ctl, ELCL_BLOCK1, ELCL_LNK_2, ELCL_FLIP_FLOP0_INPUT);
Elcl_link_to_logic(&elcl_ctl, ELCL_BLOCK1, ELCL_LNK_6, ELCL_FLIP_FLOP0_CLK);
Elcl_link_to_logic(&elcl_ctl, ELCL_BLOCK1, ELCL_LNK_0, ELCL_CELL0_INPUT_0);
Elcl_link_to_logic(&elcl_ctl, ELCL_BLOCK1, ELCL_LNK_1, ELCL_CELL0_INPUT_1);</code></pre>
						</li>
					</ul>
				</li>
				<li>ELCL Block 2:
					<ul>
						<li><b>Elcl_link_input</b>: Link outputs from block 1's logic gates to block 2.
							<pre class="no-copy"><code class="C">Elcl_link_input(&elcl_ctl, ELCL_BLOCK2, ELCL_LNK_0, ELCL_OUTPUT_FLIP_FLOP0_L1, ELCL_INVERTED_LOGIC);
Elcl_link_input(&elcl_ctl, ELCL_BLOCK2, ELCL_LNK_1, ELCL_OUTPUT_FLIP_FLOP0_L1, ELCL_POSITIVE_LOGIC);
Elcl_link_input(&elcl_ctl, ELCL_BLOCK2, ELCL_LNK_2, ELCL_OUTPUT_CELL0_L1, ELCL_INVERTED_LOGIC);
Elcl_link_input(&elcl_ctl, ELCL_BLOCK2, ELCL_LNK_3, ELCL_OUTPUT_CELL0_L1, ELCL_INVERTED_LOGIC);</code></pre>
						</li>
						<li><b>Elcl_set_logic</b>: Enable the logic gates of interest in logic block 2.
							<pre class="no-copy"><code class="C">Elcl_set_logic(&elcl_ctl, ELCL_BLOCK2, ELCL_AND_CELL_0);
Elcl_set_logic(&elcl_ctl, ELCL_BLOCK2, ELCL_AND_CELL_1);</code></pre>
						</li>
						<li><b>Elcl_link_to_logic</b>: Link the input link registers for block 2 to the logic cells.
							<pre class="no-copy"><code class="C">Elcl_link_to_logic(&elcl_ctl, ELCL_BLOCK2, ELCL_LNK_0, ELCL_CELL0_INPUT_0);
Elcl_link_to_logic(&elcl_ctl, ELCL_BLOCK2, ELCL_LNK_2, ELCL_CELL0_INPUT_1);
Elcl_link_to_logic(&elcl_ctl, ELCL_BLOCK2, ELCL_LNK_1, ELCL_CELL1_INPUT_0);
Elcl_link_to_logic(&elcl_ctl, ELCL_BLOCK2, ELCL_LNK_3, ELCL_CELL1_INPUT_1);</code></pre>
						</li>
					</ul>
				</li>
				<li><b>Elcl_set_output &amp; <b></b>Elcl_set_output_state</b>: Select the ELCL outputs &amp; their
					source's from
					within the ELCL - then enable them.
					<pre class="no-copy"><code class="C">Elcl_set_output(&elcl_ctl, ELCL_OUTPUT_3, ELCL_OUTPUT_L2_CELL0, ELCL_POSITIVE_LOGIC);
Elcl_set_output(&elcl_ctl, ELCL_OUTPUT_4, ELCL_OUTPUT_L2_CELL1, ELCL_POSITIVE_LOGIC);
Elcl_set_output_state(&elcl_ctl, ELCL_OUTPUT_3, ELCL_OUTPUT_ENABLED);
Elcl_set_output_state(&elcl_ctl, ELCL_OUTPUT_4, ELCL_OUTPUT_ENABLED);</code></pre>
				</li>
			</ol>

			<p>
			</p>

		</details>

		<!-- Prepare the pages modal images-->
		<script>lab_templater.Prepare_modal();</script>

		<!-- Button for going to the next page-->
		<script>lab_templater.Generate_next_page_button("Next...");</script>

		<!-- Setup code copying functionality on all appropriately formatted code snippets-->
		<script>Setup_code_copy();</script>

	</div>
</body>

</html>